import { Agent, AgentConfig, AgentMessage } from './agent-base';
import { AnalyticsClient } from '../../.kiro/mcp/clients/analytics-client';
import { TranslationResult } from './code-translator-agent';
import { ParseResult } from './legacy-parser-agent';

export interface TestGenerationRequest {
  translationResult: TranslationResult;
  parseResult: ParseResult;
  sourceFile: string;
}

export interface TestSuite {
  unitTests: string;
  integrationTests: string;
  regressionTests: string;
  coverage: {
    lines: number;
    functions: number;
    branches: number;
  };
  testCount: number;
}

export class TestGeneratorAgent extends Agent {
  private analytics: AnalyticsClient;
  
  constructor(config: AgentConfig) {
    super(config);
    this.analytics = new AnalyticsClient();
  }
  
  protected async onStart(): Promise<void> {
    console.log(`[${this.config.name}] Starting test generator agent`);
    this.setMemory('generatedTests', []);
    this.setMemory('totalTestsGenerated', 0);
  }
  
  protected async onStop(): Promise<void> {
    console.log(`[${this.config.name}] Stopping test generator agent`);
    await this.analytics.flush();
  }
  
  // STEP 1: Handle test generation requests
  protected async onRequest(message: AgentMessage): Promise<void> {
    const request = message.payload as TestGenerationRequest;
    const startTime = Date.now();
    
    try {
      // STEP 2: Generate test suite
      const testSuite = await this.generateTests(request);
      
      // STEP 3: Track metrics
      const duration = Date.now() - startTime;
      const testsPerMinute = (testSuite.testCount / duration) * 60000;
      
      await this.analytics.sendMetric({
        name: 'test.generation_speed',
        value: testsPerMinute,
        unit: 'tests/min',
        tags: {
          agentId: this.config.id
        }
      });
      
      await this.analytics.sendMetric({
        name: 'test.coverage',
        value: testSuite.coverage.lines,
        unit: 'percent',
        tags: {
          type: 'lines',
          agentId: this.config.id
        }
      });
      
      // STEP 4: Update memory
      const generatedTests = this.getMemory('generatedTests') || [];
      generatedTests.push(request.sourceFile);
      this.setMemory('generatedTests', generatedTests);
      
      const totalTests = this.getMemory('totalTestsGenerated') || 0;
      this.setMemory('totalTestsGenerated', totalTests + testSuite.testCount);
      
      // STEP 5: Notify completion
      await this.sendMessage('orchestrator', 'notification', {
        event: 'tests_generated',
        sourceFile: request.sourceFile,
        testSuite,
        coverage: testSuite.coverage
      });
      
    } catch (error: any) {
      this.emit('error', {
        error,
        agentId: this.config.id,
        toolName: 'generate_tests',
        context: { sourceFile: request.sourceFile }
      });
    }
  }
  
  protected async onNotification(message: AgentMessage): Promise<void> {
    console.log(`[${this.config.name}] Received notification:`, message.payload);
  }
  
  // STEP 6: Generate comprehensive test suite
  private async generateTests(request: TestGenerationRequest): Promise<TestSuite> {
    const { translationResult, parseResult } = request;
    
    // STEP 7: Generate unit tests
    const unitTests = this.generateUnitTests(translationResult, parseResult);
    
    // STEP 8: Generate integration tests
    const integrationTests = this.generateIntegrationTests(translationResult, parseResult);
    
    // STEP 9: Generate regression tests
    const regressionTests = this.generateRegressionTests(translationResult, parseResult);
    
    // STEP 10: Calculate coverage
    const coverage = this.calculateCoverage(translationResult, parseResult);
    
    // STEP 11: Count total tests
    const testCount = this.countTests(unitTests, integrationTests, regressionTests);
    
    return {
      unitTests,
      integrationTests,
      regressionTests,
      coverage,
      testCount
    };
  }
  
  // STEP 12: Generate unit tests for each function
  private generateUnitTests(translation: TranslationResult, parse: ParseResult): string {
    let tests = '# Unit Tests - Generated by NeuralHaunt\n\n';
    tests += 'import unittest\n';
    tests += 'from unittest.mock import Mock, patch\n\n';
    
    // Infer module name from target file
    const moduleName = translation.targetFile.replace(/\.[^.]+$/, '').replace(/\//g, '.');
    tests += `from ${moduleName} import *\n\n`;
    
    tests += 'class TestTranslatedCode(unittest.TestCase):\n\n';
    
    // STEP 13: Generate test for each function
    parse.functions.forEach((func, index) => {
      const pythonFuncName = func.name.toLowerCase().replace(/-/g, '_');
      
      tests += `    def test_${pythonFuncName}_basic(self):\n`;
      tests += `        """Test basic functionality of ${func.name}"""\n`;
      tests += `        result = ${pythonFuncName}()\n`;
      tests += `        self.assertIsNotNone(result)\n\n`;
      
      tests += `    def test_${pythonFuncName}_edge_cases(self):\n`;
      tests += `        """Test edge cases for ${func.name}"""\n`;
      tests += `        # TODO: Add edge case tests\n`;
      tests += `        pass\n\n`;
    });
    
    tests += 'if __name__ == "__main__":\n';
    tests += '    unittest.main()\n';
    
    return tests;
  }
  
  // STEP 14: Generate integration tests
  private generateIntegrationTests(translation: TranslationResult, parse: ParseResult): string {
    let tests = '# Integration Tests - Generated by NeuralHaunt\n\n';
    tests += 'import unittest\n';
    tests += 'from unittest.mock import Mock, patch\n\n';
    
    const moduleName = translation.targetFile.replace(/\.[^.]+$/, '').replace(/\//g, '.');
    tests += `from ${moduleName} import *\n\n`;
    
    tests += 'class TestIntegration(unittest.TestCase):\n\n';
    
    // STEP 15: Test interactions between functions
    if (parse.functions.length > 1) {
      tests += `    def test_function_interactions(self):\n`;
      tests += `        """Test interactions between translated functions"""\n`;
      tests += `        # TODO: Add integration tests\n`;
      tests += `        pass\n\n`;
    }
    
    // STEP 16: Test dependency handling
    if (parse.dependencies.length > 0) {
      tests += `    def test_dependency_handling(self):\n`;
      tests += `        """Test handling of external dependencies"""\n`;
      tests += `        # Dependencies: ${parse.dependencies.join(', ')}\n`;
      tests += `        pass\n\n`;
    }
    
    tests += 'if __name__ == "__main__":\n';
    tests += '    unittest.main()\n';
    
    return tests;
  }
  
  // STEP 17: Generate regression tests
  private generateRegressionTests(translation: TranslationResult, parse: ParseResult): string {
    let tests = '# Regression Tests - Generated by NeuralHaunt\n\n';
    tests += 'import unittest\n\n';
    
    const moduleName = translation.targetFile.replace(/\.[^.]+$/, '').replace(/\//g, '.');
    tests += `from ${moduleName} import *\n\n`;
    
    tests += 'class TestRegression(unittest.TestCase):\n\n';
    
    // STEP 18: Test for known deprecated patterns
    if (parse.metadata.deprecatedPatterns.length > 0) {
      parse.metadata.deprecatedPatterns.forEach((pattern, index) => {
        tests += `    def test_deprecated_pattern_${index}(self):\n`;
        tests += `        """Ensure ${pattern} is properly handled"""\n`;
        tests += `        # TODO: Verify behavior matches legacy system\n`;
        tests += `        pass\n\n`;
      });
    }
    
    tests += `    def test_output_equivalence(self):\n`;
    tests += `        """Test that output matches legacy system"""\n`;
    tests += `        # TODO: Compare with legacy system output\n`;
    tests += `        pass\n\n`;
    
    tests += 'if __name__ == "__main__":\n';
    tests += '    unittest.main()\n';
    
    return tests;
  }
  
  // STEP 19: Calculate test coverage
  private calculateCoverage(translation: TranslationResult, parse: ParseResult): TestSuite['coverage'] {
    // Simplified coverage calculation
    const totalFunctions = parse.functions.length;
    const testedFunctions = totalFunctions; // All functions get at least basic tests
    
    // Estimate line coverage based on function coverage
    const functionCoverage = totalFunctions > 0 ? (testedFunctions / totalFunctions) * 100 : 0;
    const lineCoverage = functionCoverage * 0.85; // Assume 85% of lines covered when functions are tested
    const branchCoverage = functionCoverage * 0.70; // Branch coverage typically lower
    
    return {
      lines: Math.round(lineCoverage),
      functions: Math.round(functionCoverage),
      branches: Math.round(branchCoverage)
    };
  }
  
  // STEP 20: Count total number of tests generated
  private countTests(unitTests: string, integrationTests: string, regressionTests: string): number {
    const countInFile = (content: string) => {
      const matches = content.match(/def test_/g);
      return matches ? matches.length : 0;
    };
    
    return countInFile(unitTests) + countInFile(integrationTests) + countInFile(regressionTests);
  }
}